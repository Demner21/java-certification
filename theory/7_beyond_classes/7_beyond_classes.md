# Objetivos 
- Crear y usar interfaces, idedntificar interfaces funcionales y utilizar métodos privados, static y default en interfaces
- Declarar e instanciar objetos java incluyendo objetos de clases nested
- Explicar el ciclo de vida del objeto: creacion, reasignacion de referencia y garbage collection


# Implementar interfaces
>Una clase puede implementar cualquier numero de interfaces

>Una interface es un tipo de dato ***abstracto*** que declara una lista de métodos abstractos que cualquier clase debe implementar
- The most simple interface example
```
public abstract interface MySimpleInterface{
}
```
- An nterface with one simple method and one constant
```
public abstract interface MyInterface{
    public abstract int getTip(); // public and abstract are implicit modifiers
    public static final String MY_CONSTANT="C"; //public static and final are implicit modifiers
}
```

## Declarando herencia
```
public class Mammal{} //parent class::superclass

public final class Rhinoceros extends Mammal {}  //child class ::subclass
```

# Encapsulando data con Records
```
record MyRecord(String name) {

    //canonical constructor
    /*MyRecord(String name) {
        name = name.isBlank() ? "Tom" : name;
        this.name = name;
    }*/

    //compact constructor
    MyRecord {
        name = name.isBlank() ? "Tom" : name;
    }

    static int getConstant() {
        return Double.valueOf("21").intValue();
    }


    public static void main(String[] args) {
        var listRecords
                = List.of(new MyRecord(""), new MyRecord("Eru"));

        listRecords.stream()
                .map(MyRecord::name)
                .forEach(System.out::println);

        System.out.println(MyRecord.getConstant());
    }
}
```
```
Tom
Eru
21
```

> Just as interfaces are implicitly abstract, records are also implicitly final. 

> The final modifier is optional but assumed.
```
public final record Demo(String name);
```
> los records son **final** implicitamente, no pueden ser heredados
## Constructores
- Normal Canonical Constructor aka Long Constructor
   
   ```
    public record MyRecord(String name){

        public MyRecord(String name){
            name = name.isBlank() ? "Tom" : name;
            this.name=name;
        }
    }
   ``` 
- Compact Constructor: 
    > usado para validaciones y transformaciones
    
    > no requiere parametros 
   ```
    public record MyRecord(String name){

        public MyRecord{
            name = name.isBlank() ? "Tom" : name;
        }
    }
   ``` 

- Overload Constructors
> Take completely different number of arguments

> The first line of an overloaded constructor must be an explicit call to another constructor via this().
```
record Time(int hrs, int min) {
    Time() {        // no-arg, noncanonical constructor
        this(0);    // delegates to the constructor below
    }
    Time(int hrs) { // another noncanonical constructor
                    // delegates to the autogenerated canonical constructor
        this(hrs, 0);
    }
}
```


# Creating Nested classes
> A nested class is a class that is defined within another class

A nested class can come in one of four flavors

1. inner class: clases no estaticas definidas al mismo nivel de miembros : { methods, constructor, fields }
2. static nested class: clases estaticas definidas al mismo nivel de miembros : { methods, constructor, fields }
3. local class: clases definidas dentro del cuerpo de un metodo 
4.  anonymous class: caso especial de una clase local que no tiene nombre
---

```
package org.example.nested;

public class SimpleClass {

    private final class InnerClassA {
        static void method() {
            System.out.println("inner class A");
        }

        void method2() {
            System.out.println("inner class A//method 2");
        }

    }
}
```





